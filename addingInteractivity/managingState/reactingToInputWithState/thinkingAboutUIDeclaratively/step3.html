<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Step 3 - Represent the state in memory with useState</title>
</head>
<body>
  <!-- Div for rendering -->
  <div id="main"></div>

  <!-- Scripts for React, React DOM & Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- General script -->
  <script type="text/jsx">
    const hrefUseState = "https://react.dev/reference/react/useState"
    function Intro (){
      return (
        <>
          <h1>Step 3 - Represent the state in memory with <span className="grey-bg">useState</span></h1>
          <p>Next you'll need to represent the visual states of your component in memory with <a href={hrefUseState}><span className="grey-bg">useState</span>.</a> Simplicity is key: each piece of state is a "moving piece", and you want as few "moving pieces" as possible. More complexity leads to more bugs!</p>
          <p>Start with the state that absolutly must be there. For example, you'll need to store the <span className="grey-bg">answer</span> for the input, and the <span className="grey-bg">error</span> (if it exists) to store the last error:</p>
          <div className="box">
            <p><span className="blue">const</span> [answer, setAnswer] = <span className="turquoise">useState</span>(<span className="purple">''</span>);</p>
            <p><span className="blue">const</span> [error, setError] = <span className="turquoise">useState</span>(<span className="blue">null</span>);</p>
          </div>
          <p>Then, you'll need a state variable representing wich one of the visual states that you want to display. There's usually more than a single way to represent that in memory, so you'll need to experiment with it.</p>
          <p>If you struggle to think of the best way immediatly, start by adding enough state that you're definitely sure that all the possible visual states are covered:</p>
          <div className="box">
            <p><span className="blue">const</span> [isEmpty, setIsEmpty] = <span className="turquoise">useState</span>(<span className="red">true</span>);</p>
            <p><span className="blue">const</span> [isTyping, setIsTyping] = <span className="turquoise">useState</span>(<span className="red">false</span>);</p>
            <p><span className="blue">const</span> [isSubmitting, setIsSubmitting] = <span className="turquoise">useState</span>(<span className="red">false</span>);</p>
            <p><span className="blue">const</span> [isSuccess, setIsSucces] = <span className="turquoise">useState</span>(<span className="red">false</span>);</p>
            <p><span className="blue">const</span> [isError, setIsError] = <span className="turquoise">useState</span>(<span className="red">false</span>);</p>
          </div>
          <p>Your furst idea likely won't be the best, but that's ok - refactoring state is a part of the process!</p>
        </>
      )
    }

    ReactDOM.render(<Intro/>, main)
  </script>
</body>
</html>