<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Updating Objects in State</title>
</head>
<body>
  <!-- div for rendering -->
  <div id="main"></div>

  <!-- scripts for React, React DOM & Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- General script -->
  <script type="text/jsx">
    const curlyBracket = ["{", "}"]
    function Intro(){
      return(
        <>
          <h1>Updating Objects in State</h1>
          <p>State can hold any kind of JavaScript value, including objects. But you shouldn't change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy.</p>
          <h2>What's a mutation?</h2>
          <p>You can store any kind of JavaScript value in state.</p>
          <p><span className="blue">const</span> [x, setX] = <span className="turquoise">useState</span>(<span className="red">0</span>);</p>
          <p>So far I been working with numbers, strings, and booleans. These kind of JavaScript values are "immutable", meaning unchangeable or "read-only". You can trigger a re-render to replace a value:</p>
          <p><span className="turquoise">setX(<span className="red">5</span>)</span>;</p>
          <p>The <mark>x</mark> state changed from <mark>0</mark> to <mark>5</mark>, but <mark>0</mark> itself did not change. It's not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.</p>
          <p>Now consider an object in state:</p>
          <p><span className="blue">const</span> [position, setPosition] = <span className="turquoise">useState</span>( {curlyBracket[0]}<span className="blue">x</span>: <span className="red">0</span>, <span className="blue">y</span>: <span className="red">0 </span>{curlyBracket[1]});</p>
          <p>Techically, it's possible to change the contents of the object itself. This is called a <b>mutation</b>:</p>
          <p>position.<span className="blue">x </span>= <span className="red">5</span>;</p>
          <p>However, although objects in React state are technically mutable, you should treat them as if  they were immutable--like numbers, booleans, and strings. Instead of mutating them, you should always replace them.</p>
          <h2>Treat state as read-only</h2>
          <p>In other words, you should treat any JavaScript object that you put into state as read-only.</p>
          <p>Mutating state can work in some cases, but it's not recommended. <b>You should treat the state value you have access to in a render as read-only</b></p>
        </>
      )
    }

    function LocalMutation(){
      return(
        <>
          <h2>Local mutation is fine</h2>
          <p>Code like this is a problem it modifies an existing object in state:</p>
          <div className="box">
            <pre>
              position.x = e.clientX;
              <br/>
              position.y = e.clientY;
            </pre>
          </div>
          <p>But code like this is absolutly fine because you're mutating a fresh object you have just created:</p>
          <div className="box">
            <pre>
              const nextPosition = {curlyBracket[0]} {curlyBracket[1]};
              <br/>
              nextPosition.x = e.clientX;
              <br/>
              nextPosition.y = e.clientY;
              <br/>
              setPosition(nextPosition);
            </pre>
          </div>
          <p>In fact, it is completly equivalent to writing this:</p>
          <div className="box">
            <pre>
              setPosition({curlyBracket[0]}
                <br/>
                <span className="tab">x: e.clientX,</span>
                <br/>
                <span className="tab">y: e.clientY,</span>
                <br/>
              {curlyBracket[1]});
            </pre>
          </div>
          <p>Mutation is only a problem when you change existing objects that are already in state. Mutating an object you've just created is okay because no other code references it yet. Changing it isn't going to accidentaly impact something that depends on it. This is called a "local mutation". You can even do local mutation <span className="blue">while rendering</span>. Very convenient and completly okay!</p>
        </>
      )
    }

    function SpreadSyntax(){
      const spreadSyntax = "https://react.dev/learn/updating-objects-in-state#copying-objects-with-the-spread-syntax"
      return(
        <>
          <h2>Copying objects with the spread syntax</h2>
          <p>Sometimes you will want to include existing data as a part of the new object you're creating. For example, you may want to update only one field in a form, but keep the previous values for all other fields.</p>
          <p>For example, this line mutates the state from a past render (Imagin some render or take a look at the code in <a href="https://react.dev/learn/updating-objects-in-state#copying-objects-with-the-spread-syntax">copying objects with spread syntax</a>):</p>
          <div className="box">
            <p>person.<span className="blue">firstName</span> = e.<span className="blue">target</span>.<span className="blue">value</span></p>
          </div>
          <p>The reliable way to get the behaivor you're looking for is to create a new object and pass it to <span className="greyBackground">setPerson</span>. But here, you want also copy the existing data into it because only one of the fields has changed:</p>
          <div className="box">
            <span className="turquoise">setPerson</span>({curlyBracket[0]}
            <br/>
            <span className="tab">
              <span className="blue">firstName</span>: e.<span className="blue">target</span>.<span className="blue">value</span>, <span className="grey">// New first name from the input</span>
            </span>
            <br/>
            <span className="tab">
              <span className="blue">lastName</span>: person.<span className="blue">lastName</span>
            </span>
            <br/>
            <span className="tab">
              <span className="blue">email</span>: person.<span className="blue">email</span>
            </span>
            <br/>
            {curlyBracket[1]});
          </div>
          <p>You can use the <span className="greyBackground">...</span> <span className="blue">object spread</span> syntax so that you don't need to copy every property separately.</p>
          <div className="box">
            <span className="turqouise">setPerson</span>({curlyBracket[0]}
            <br/>
            <span className="tab">...person, <span className="grey">// Copy the old fields</span></span>
            <br/>
            <span className="tab blue">firstName</span>
            : e.
            <span className="blue">target</span>
            .
            <span className="blue">value </span>
            <span className="grey">// But override this one</span>
            <br/>
            {curlyBracket[1]});
          </div>
          <p>Keeping all data grouped in an object is very convenient -- as long as you update it correctly!</p>
        </>
      )
    }

    ReactDOM.render(<SpreadSyntax/>, main)
  </script>
</body>
</html>